<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Java并发编程的艺术 —— 并发编程的挑战 · Hexo</title><meta name="description" content="Java并发编程的艺术 —— 并发编程的挑战 - John Doe"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Java并发编程的艺术 —— 并发编程的挑战</h1><div class="post-info">Jul 30, 2017</div><div class="post-content"><h1 id="并发编程的挑战"><a href="#并发编程的挑战" class="headerlink" title="并发编程的挑战"></a>并发编程的挑战</h1><h3 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h3><blockquote>
<p>​    CPU 通过时间片分配算法来 <em>循环</em> 执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会 <em>保存</em> 上一个任务的状态，以便下一次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。<a id="more"></a> </p>
</blockquote>
<h5 id="减少上下文切换"><a href="#减少上下文切换" class="headerlink" title="减少上下文切换"></a>减少上下文切换</h5><p>​    减少上下文切换的方法有无锁并发编程、CAS 算法、使用最少线程和使用协程。</p>
<ul>
<li>无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程可以用一些办法来 <strong>避免</strong> 使用锁。</li>
<li>CAS 算法：Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要锁。</li>
<li>协程：在单线程里实现多任务的 <em>调度</em> ，并在单线程里维持多个任务间的切换。</li>
</ul>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>​    避免死锁的方法：</p>
<ul>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用 lock.tryLock(timeout) 来替代使用 <em>内部锁</em> 机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个 <em>数据库连接</em> 里,否则会出现解锁失败的情况。</li>
</ul>
<h3 id="资源限制的挑战"><a href="#资源限制的挑战" class="headerlink" title="资源限制的挑战"></a>资源限制的挑战</h3><ol>
<li><p>什么是资源限制</p>
<p>​    资源限制是指在进行并发编程时，程序执行速度 <em>受限于</em> 计算机硬件资源或软件资源。所以在进行并发编程时，要 <strong>考虑</strong> 这些资源的限制。</p>
<p>​    硬件资源限制有带宽的上传/下载速度、硬盘读写速度和 CPU 的处理速度。软件资源限制有数据库的连接数和 socket 连接数等。</p>
</li>
<li><p>资源限制引发的问题</p>
<p>​    如果某段串行的代码并行执行，因为受限于资源，仍然在串行执行，这时候程序会因为增加上下文切换和资源调度的时间，反而更慢。</p>
</li>
<li><p>如何解决资源限制的问题</p>
<p>​    对于硬件资源限制，可以考虑使用集群并行执行程序，让程序在多机上运行。</p>
<p>​    对于软件资源限制，可以考虑使用资源池将资源复用。</p>
</li>
<li><p>在资源限制的情况下进行并发编程</p>
<p>​    根据不同资源限制调整程序的并发度。</p>
</li>
</ol>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>​    <strong>多使用 JDK 并发包提供的并发容器和工具类来解决并发问题，因为这些了类都已经通过了充分的测试和优化。</strong></p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/08/04/Kotlin/" class="prev">PREV</a><a href="/2017/07/27/与设计模式相处/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>