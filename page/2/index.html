<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Hexo</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Hexo"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://weibo.com/u/1038839880" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/chenyigg" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><ul class="home post-list"><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/25/模板方法模式/" class="post-title-link">设计模式 之 模板方法模式</a></h2><div class="post-info">Jul 25, 2017</div><div class="post-content"><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><blockquote>
<p><strong>模板方法模式</strong> 在一个方法中定义一个算法的 <strong>骨架</strong> ，而将一些步骤 <strong>延迟</strong> 到子类中。</div><a href="/2017/07/25/模板方法模式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/25/适配器模式与外观模式/" class="post-title-link">设计模式 之 适配器模式与外观模式</a></h2><div class="post-info">Jul 25, 2017</div><div class="post-content"><h1 id="适配器模式与外观模式"><a href="#适配器模式与外观模式" class="headerlink" title="适配器模式与外观模式"></a>适配器模式与外观模式</h1><blockquote>
<p> <strong>适配器模式</strong> 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口 <em>不兼容</em> 的类可以合作无间。</div><a href="/2017/07/25/适配器模式与外观模式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/25/命令模式/" class="post-title-link">设计模式 之 命令模式</a></h2><div class="post-info">Jul 25, 2017</div><div class="post-content"><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><blockquote>
<p> <strong>命令模式</strong> 将 “请求” <em>封装</em> 成对象，以便使用不同的请求、队列或者日志来 <em>参数化</em> 其他对象。命令模式也支持 <em>可撤销</em> 的操作。</div><a href="/2017/07/25/命令模式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/24/单件模式/" class="post-title-link">设计模式 之 单件模式</a></h2><div class="post-info">Jul 24, 2017</div><div class="post-content"><h1 id="单件模式"><a href="#单件模式" class="headerlink" title="单件模式"></a>单件模式</h1><blockquote>
<p><strong>单件模式</strong> 确保一个类只有一个实例，并提供一个全局访问点。</div><a href="/2017/07/24/单件模式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/24/工厂模式/" class="post-title-link">设计模式 之 工厂模式</a></h2><div class="post-info">Jul 24, 2017</div><div class="post-content"><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><blockquote>
<p><strong>工厂方法模式</strong> 定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。</p>
<p><strong>抽象工厂模式</strong> 提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。</div><a href="/2017/07/24/工厂模式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/24/装饰者模式/" class="post-title-link">设计模式 之 装饰者模式</a></h2><div class="post-info">Jul 24, 2017</div><div class="post-content"><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><blockquote>
<p><strong>装饰者模式</strong> 动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</div><a href="/2017/07/24/装饰者模式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/24/观察者模式/" class="post-title-link">设计模式 之 观察者模式</a></h2><div class="post-info">Jul 24, 2017</div><div class="post-content"><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><blockquote>
<p><strong>观察者模式</strong> 定义了对象之间的<em>一对多</em>依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。</div><a href="/2017/07/24/观察者模式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/23/策略模式/" class="post-title-link">设计模式 之 策略模式</a></h2><div class="post-info">Jul 23, 2017</div><div class="post-content"><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><blockquote>
<p><strong>策略模式</strong> 定义了算法族，分别<em>封装</em>起来，让它们之间可以相互<em>替换</em>，此模式让算法的变化独立与使用算法的客户。</div><a href="/2017/07/23/策略模式/" class="read-more">...more</a></article></li><li class="post-list-item"><article class="post-block"><h2 class="post-title"><a href="/2017/07/22/Gradle-学习笔记/" class="post-title-link">Gradle 学习笔记</a></h2><div class="post-info">Jul 22, 2017</div><div class="post-content"><h2 id="Gradle"><a href="#Gradle" class="headerlink" title="Gradle"></a>Gradle</h2><blockquote>
<p>良好的编码习惯和风格，对于减少不必要的 Gradle 问题是很有帮助的。</div><a href="/2017/07/22/Gradle-学习笔记/" class="read-more">...more</a></article></li></ul></main><footer><div class="paginator"><a href="/" class="prev">PREV</a></div><div class="copyright"><p>© 2017 <a href="http://yoursite.com">John Doe</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>